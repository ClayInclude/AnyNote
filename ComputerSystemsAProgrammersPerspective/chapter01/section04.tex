\section{处理器读并解释储存在内存中的指令}
{
    此刻，\emcode{hello.c}源程序已经被编译系统翻译成了可执行目标文件\emcode{hello}，并被存放在磁盘上。
    要想在Unix系统上运行该可执行文件，将它的文件名输入到称为shell的应用程序中：

    \begin{codelist}
        \lstinputlisting[firstline = 3, lastline = 5]{./code/shell_collection}
    \end{codelist}

    shell是一个命令解释器，它输出一个提示符，等待输入一个命令，然后执行这个命令。
    如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。
    在此例中，shell将加载并运行hello程序，然后等待程序终止。
    hello程序在屏幕上输出它的消息，然后终止。
    shell随后输出一个提示符，等待下一个输入的命令行。

    \subsection{系统的硬件组成}
    {
        \subsubsection{总线}
        {
            贯穿整个系统的是一组电子管道，称作\emreg{总线}，它携带信息字节并负责在各个部件间传递。
            通常总线被设计成传送定长的字节块，也就是\emreg{字(word)}。
            字中的字节数（即\emreg{字长})是一个基本的系统参数，各个系统中都不尽相同。
        }

        \subsubsection{I/O设备}
        {
            I/O设备是系统与外部世界的联系通道。
            我们的示例系统包括四个I/O设备：
            作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器。
            最开始，可执行程序\emcode{hello}就存放在磁盘上。

            每个I/O设备都通过一个\emreg{控制器}或\emreg{适配器}与I/O总线相连。
            控制器和适配器之间的区别主要在于它们的封装方式。
            控制器是I/O设备本身或者系统的主印刷电路板（通常称作\emreg{主板}）上的芯片组。
            而适配器则是一块插在主板插槽上的卡。
            无论如何，它们的功能都是在I/O总线和I/O设备之间传递信息。
        }

        \subsubsection{主存}
        {
            \emreg{主存}是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。
            从物理上来说，主存是由一组\emreg{动态随机存取存储器(DRAM)}芯片组成的。
            从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。
            一般来说，组成程序的每条机器指令都由不同数量的字节构成。
            与C程序变量相对应的数据项的大小是根据类型变化的。
        }

        \subsubsection{处理器}
        {
            \emreg{中央处理单元}，简称\emreg{处理器}，是解释（或\emreg{执行}）存储在主存中指令的引擎。
            处理器的核心是一个大小为一个字的存储设备（或\emreg{寄存器}），称为\emreg{程序计数器(PC)}。
            在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。

            从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。
            处理器\emreg{看上去}是按照一个非常简单的指令执行模型来操作的，这个模型是由\emreg{指令集架构}决定的。
            在这个模型中，指令按照严格的顺序执行，而执行一个条指令包含执行一系列的步骤。
            处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

            这样的简单操作并不多，他们围绕着主存、\emreg{寄存器文件(register file)}和\emreg{算数/逻辑单元(ALU)}进行。
            寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。
            ALU计算新的数据和地址值。
            下面是一些简单操作的例子：

            \begin{description}
                \item[加载] 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
                \item[存储] 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
                \item[操作] 把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
                \item[跳转] 从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖PC中原来的值。
            \end{description}

            处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。
            因此，我们将处理器的指令集架构和处理器的\emreg{微体系结构}区分开来：
            指令集架构描述的是每条机器代码指令的效果；
            而微体系结构描述的是处理器实际上是如何实现的。
            在第三章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽象性。
            第四章将更详细的介绍处理器实际上是如何实现的。
            第五章用一个模型说明现代处理器是如何工作的，从而能预测和优化机器语言程序的性能。
        }
    }

    \subsection{运行\emcode{hello}程序}
    {
        初始时，shell程序执行它的指令，等待我们输入一个命令。
        当我们在键盘上输入字符串后，shell程序将字符逐一读入寄存器，再把它放到内存中。

        当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。
        然后shell执行一系列指令来加载可执行的\emcode{hello}文件，这些指令将\emcode{hello}目标文件中的代码和数据从磁盘复制到主存。
        数据包括最终会被输出的字符串\emcode{hello, world\textbackslash n}。

        利用\emreg{直接存储器存取(DMA)}技术，数据可以不通过处理器而直接从磁盘到达主存。

        一旦目标文件\emcode{hello}中的代码和数据被加载到内存，处理器就开始执行\emcode{hello}程序的\emcode{main}函数中机器语言指令。
        这些指令将\emcode{hello, world\textbackslash n}字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。
    }
}

\endinput
