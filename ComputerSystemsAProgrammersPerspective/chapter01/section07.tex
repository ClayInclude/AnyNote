\section{操作系统管理硬件}
{
    让我们回到hello程序的例子。
    当shell加载和运行hello程序时，以及hello程序程序输出自己的消息时，shell和hello程序都没有直接访问键盘、显示器、磁盘或者主存。
    取而代之的是，它们依靠\emreg{操作系统}提供的服务。
    我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。
    所有应用程序对硬件的操作尝试都必须通过操作系统。

    操作系统有两个基本功能：
    防止硬件被失控的应用程序滥用；
    向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。
    操作系统通过几个基本的抽象概念(\emreg{进程}、\emreg{虚拟内存}和\emreg{文件})来实现这两个功能。
    文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

    \begin{sidenote}[Unix、Posix和标准Unix规范]
        一群贝尔实验室的研究人员---Ken Thompson、Dennis Ritchie、Doug Mcllroy和Joe Ossanna，从1969年开始在DEC PDP--7计算机上完全用机器语言编写了一个简单得多的操作系统。
        这个新系统中的很多思想，比如层次文件系统、作为用户级进程的shell概念，都是来自于Multics，只不过在一个更小、更简单的程序包里实现。
        1970年，Brian Kernighan给新系统命名为Unix，这也是一个双关语，安置Multics的复杂性。
        1973年用C重新编写其内核，1974年，Unix开始正式对外发布。

        贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并以持续发展。
        最有影响的工作发生在20世纪70年代晚期到80年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和Internet协议，称为Unix 4.xBSD(Berkeley Software Distribution)。
        与此同时，贝尔实验室也在发布自己的版本，称为System V Unix。
        其他厂商的版本，比如Sun Microsystems的Solaris系统，则是从这些原始的BSD和System V版本中衍生而来。

        20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。
        为了阻止这种趋势，IEEE（电气和电子工程师协会）开始努力标准化Unix的开发，后来由Richard Stallman命名为Posix。
        结果就得到了一系列的标准，称作Posix标准。
        这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。
        最近，一个被称为``标准Unix规范''的独立标准化工作已经与Posix一起创建了统一的Unix系统标准。
        这些标准化工作的结果是Unix版本之间的差异已经基本消失。
    \end{sidenote}

    \subsection{进程}
    {
        像\emcode{hello}这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。
        程序看上去是独占地使用处理器、主存和I/O设备。
        处理器看上去就像在不间断地一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。
        这些假象是通过进程的概念来实现的，京城是计算机科学中最重要和最成功的概念之一。

        \emreg{进程}是操作系统对一个正在运行的程序的一种抽象。
        在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。
        而\emreg{并发运行}，则是说一个进程的指令和另一个进程的指令是交错执行的。
        在大多数系统中，需要运行的进程数是多余可以运行它们的CPU个数的。
        传统系统在一个时刻只能执行一个程序，而先进的\emreg{多核}处理器能够同时执行多个进程。
        无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。
        操作系统实现这种交错执行的机制称为\emreg{上下文切换}。

        操作系统保持跟踪进程所需的所有状态信息。
        这种状态（\emreg{上下文}）包括许多信息，比如PC核寄存器文件的当前值，以及主存的内容。
        在任何一个时刻，单处理器系统都只能执行一个进程的代码。
        当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行\emreg{上下文切换}，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。
        新进程就会从它上次停止的地方开始。

        从一个进程到另一个进程的转换是由操作系统\emreg{内核(kernel)}管理的。
        内核时操作系统代码常驻内存的部分。
        当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的\emreg{系统调用(system call)}指令，将控制权传递给内核。
        然后内核执行被请求的操作并返回应用程序。
        内核不是一个独立的进程。
        相反，它是系统管理全部进程所有代码和数据结构的集合。

        实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。
    }

    \subsection{线程}
    {
        尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为\emreg{线程}的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
        由于网络服务器中对并行处理的需求，线程成位越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。
        当有多处理器可用的时候，多线程也是一种使得程序可以运行更快的方法。
    }

    \subsection{虚拟内存}
    {
        \emreg{虚拟内存}是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。
        每个进程看到的内存都是一致的，称为\emreg{虚拟地址空间}。

        每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。
        在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。
        我们从最低的地址开始，逐步向上介绍：

        \begin{description}
            \item[程序代码和数据]
            {
                对所有的进程来说，代码是从同一固定地址开始，紧接着的是喝C全局变量相对应的数据位置。
                代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件\emcode{hello}。
            }
            \item[堆]
            {
                代码和数据区后紧随着的是运行时\emreg{堆}。
                代码和数据区在进程一开始运行时就被指定了大小，与此不同，堆可以在运行时动态地扩展和收缩。
            }
            \item[共享库]
            {
                大约在地址空间的部分是一块用来存放像标准库和数学库这样的共享库的代码和数据的区域。
                共享库的概念非常强大，也相当难懂。
            }
            \item[栈]
            {
                位于用户虚拟地址空间顶部的是\emreg{用户栈}，编译器用它来实现函数调用。
                和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。
                特别地，每次调用一个函数时，栈就会增长；
                从一个函数返回时，栈就会收缩。
            }
            \item[内核虚拟内存]
            {
                地址空间顶部的区域是为内核保留的。
                不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。
                相反，它们必须调用内核来执行这些操作。
            }
        \end{description}

        虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。
        基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。
    }

    \subsection{文件}
    {
        \emreg{文件}就是字节序列，仅此而已。
        每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。
        系统中的所有输入输出都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。

        文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的I/O设备。
        进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。

        \begin{sidenote}
            就像Torvalds所说的，他创建Linux的起点是Minix，由Andrew S. Tanenbaum出于教育目的开发的一个操作系统。

            接下来，如他们所说，这成就了历史。
            Linux逐渐发展为一个技术和文化现象。
            通过和GNU项目的力量结合，Linux项目发展成了一个完整的、符合Posix标准的Unix操作系统的版本，包括内核和所有支撑的基础设施。
            从手持设备到大型计算机，Linux在范围如此广泛的计算机上得到了应用。
            IBM的一个工作组甚至把Linux移植到了一块腕表中。
        \end{sidenote}
    }
}

\endinput
