\chapter{前言}
{
    本书(CS:APP)的主要读者是计算机科学家，计算机工程师，以及那些想通过计算机系统的内在运作而能够写出更好的程序的人。

    其他的系统类书籍都是从\emreg{构建者的角度}来写的，讲述如何实现硬件或系统软件，包括操作系统、编译器和网络接口。
    而本书是从\emreg{程序员的角度}来写的，讲述应用程序员如何能利用系统知识来编写出更好的程序。
    当然，学习一个计算机系统应该做些什么，是学习构建一个计算机系统的很好的出发点，所以，对于希望继续学习系统软硬件实现的人来说，本书也是一本很有价值的介绍性读物。
    大多数系统书籍还倾向于重点关注系统的某一个方面，比如：硬件架构、操作系统、编译器或者网络。
    本书则以程序员的视角统一覆盖了上述所有方面的内容。

    如果你研究和领会了这本书里的概念，你将开始成为极少数的``牛人''，这些``牛人''知道事情是如何运作的，也知道当事情出现故障时如何修复。
    你写的程序将能够更好地利用操作系统和系统软件提供的功能，对各种操作条件和运行时参数都能正确操作，运行起来更快，并能避免出现使程序容易受到网络攻击的缺陷。
    同时，也要做好更深入探究的准备，研究像编译器、计算机体系结构、操作系统、嵌入式系统、网络互联和网络安全这样的高级题目。

    \section{读者应具备的背景知识}
    {
        本书的重点是执行x86--64机器代码的系统。

        文中包含大量已在Linux系统上编译和运行过的程序示例。
        我们假设你能访问一台这样的机器，并且能够登录，做一些诸如切换目录之类的简单操作。

        我们还假设你对C和C++有一定的了解。

        本书的前几章揭示了C语言程序和它们相对应的机器语言程序之间的交互作用。
        机器语言示例都是用运行在x86--64处理器上的GNU GCC编译器生成的。
        我们不需要你以前有任何硬件、机器语言或是汇编语言编程的经验。
    }

    \section{如何阅读此书}
    {
        事实上，我们相信学习系统的唯一方法就是\emreg{做(do)}系统，即在真正的系统上解决具体的问题，或是编写和运行程序。

        除第一章外，每章后面都有难度不同的\emreg{家庭作业}。
        对于每个家庭作业，我们标注了难度级别：

        \begin{enumerate}
            \item
            {
                只需要几分钟。
                几乎或完全不需要编程。
            }
            \item
            {
                可能需要将近20分钟。
                通常包括编写和测试一些代码。
            }
            \item
            {
                需要很大的努力，也许是1--2个小时。
                一般包括编写和测试大量的代码。
            }
            \item 一个实验作业，需要将近10个小时。
        \end{enumerate}

        所有的源程序代码都可以从\url{caspp.cs.cmu.edu}上的CS:APP主页上获取。

        \begin{sidenote}[什么是旁注]
            旁注是附加说明，能使你对当前讨论的主题多一些了解。
            旁注可以有很多用处。
            一些是小的历史故事。
            例如，C语言、Linux和Internet使从何而来的？
            有些旁注则是用来澄清学生们经常感到疑惑的问题。
            例如，高速缓存的行、组和块有什么区别？
            还有些旁注给出了一些现实世界的例子。
            例如，一个浮点错误怎么毁掉了法国的一枚火箭，或是给出市面上出售的一个磁盘驱动器的几何和运行参数。
            最后，还有一些旁注仅仅就是一些有趣的内容，例如，什么是hoinky？
        \end{sidenote}
    }

    \section{本书概述}
    {
        本书由12章组成，接在阐述计算机系统的核心概念。
        内容概述如下：

        \begin{description}
            \item[第1章：计算机系统漫游] 这一章通过研究``hello, world''这个简单程序的生命周期，介绍计算机系统的主要概念和主题。
            \item[第2章：信息的表示和处理]
            {
                我们讲述了计算机的算术运算，重点描述了会对程序员有影响的无符号数和数的补码表示的特性。
                我们考虑数字是如何表示的，以及由此确定对于一个给定的字长，其可能的编码值范围。
                我们探讨有符号和无符号数字之间类型转换的效果，还阐述算术运算的数学特性。
                补码的算术运算满足很多整数运算的代数特性，因此，编译器可以很安全地把一个常量乘法转化为一系列的位移和加法。
                我们用C语言的位级操作来说明布尔代数的原理和应用。
                我们从两个方面讲述了IEEE标准的浮点格式：一是如何用它来表示数值，一是浮点运算的数学属性。

                对计算机的算术运算有深刻的理解是写出可靠程序的关键。
                算术溢出是造成程序错误和安全漏洞的一个常见根源，然而很少有书从程序员的角度来讲述计算机算术运算的特性。
            }
            \item[第3章：程序的机器级表示]
            {
                我们教读者如何阅读由C编译器生成的x86--64机器代码。
                我们说明为不同控制结构生成的基本指令模式。
                我们还讲述过程的实现，包括栈分配、寄存器使用惯例和参数传递。
                我们讨论不同数据结构的分配和访问方式。
                我们还说明实现整数和浮点数算数运算的指令。
                我们还以分析机器级程序在机器级的样子作为途径，来理解常见的代码安全漏洞，以及理解程序员、编译器和操作系统可以采取的减轻这些威胁的措施。
            }
            \item[第4章：处理器体系结构]
            {
                这一张讲述基本的组合和时序逻辑元素，并展示这些元素如何在数据通路中组合到一起，来执行x86--64指令集的一个称为Y86--64的简化子集。
                我们从设计单时钟周期数据通路开始。
                这个设计概念上非常简单，但是运行速度不会太快。
                然后我们引入\emspe{流水线}的思想，将处理一条指令所需要的不同步骤实现为独立的阶段。
                在这个设计中，任何时刻，每个阶段都可以处理不同的指令。
                本章中处理器设计的控制逻辑是用一种称为HCL的简单硬件描述语言来描述的。
            }
            \item[第5章：优化程序性能]
            {
                在这一章里，我们介绍了许多提高代码性能的技术，主要思想就是让程序员通过使编译器能够生成更有效的机器代码来学习编写C代码。
                我们一开始介绍的使减少程序需要做的工作的变换，这些是在任何机器上写程序时都应该遵循的。
                然后讲的是增加生成的机器代码中指令级并行度的变换，因而提高了程序在现代超标量处理上的性能。
                为了解释这些变换行之有效的原理，我们介绍了一个简单的操作模型，它描述了现代乱序处理器是如何工作的，然后给出了如何根据一个程序的图形化表示中的关键路径来测量一个程序可能的性能。
                你会惊讶于C代码做一些简单的变换能给程序带来多大的速度提升。
            }
            \item[第6章：存储器层次结构]
            {
                对应用程序员来说，存储器系统是计算机系统中最直接可见的部分之一。
                到目前为止，读者一致认同这样一个存储器系统概念模型，认为它是一个有一致访问时间的线性数组。
                实际上，存储器系统是一个由不同容量、造价和访问时间的存储设备组成的层次结构。
                我们讲述不同类型的随机存取存储器(RAM)和只读存储器(ROM)，以及磁盘和固态硬盘的几何形状和组织构造。
                我们描述这些存储设备是如恶化放置在层次结构中的，讲述访问局部性是如何使这种层次结构成为可能的。
                最后，我们向读者阐述如何通过改善程序的时间局部性和空间局部性来提高应用程序的性能。
            }
            \item[第7章：链接]
            {
                本章讲述静态和动态链接，包括的概念有可重定位的和可执行的目标文件、符号解析、重定位、静态库、共享目标库、位置无关代码，以及库打桩。
                大多数讲述系统的书中都不讲链接，我们讲述它是出于以下原因。
                第一，程序员遇到的最令人迷惑的问题中，有一些二和链接时的小故障有关，尤其是对那些大型软件包来说。
                第二，链接生成器的目标文件是与一些像加载、虚拟内存和内存映射这样的概念相关的。
            }
            \item[第8章：异常控制流]
            {
                在本书的这个部分，我们通过介绍异常控制流（即除正常分支和过程调用以外的控制流的变化）的一般概念，打破单一程序的模型。
                我们给出存在于系统所有层次的异常控制流的例子，从底层的硬件异常和中断，到并发进程的上下文切换，到由于接受Linux信号引起的控制流突变，到C语言中破坏栈原则的非本地跳转。

                在这一章，我们介绍\emreg{进程}的基本概念，进程是对一个正在执行的程序的一种抽象。读者会学习进程是如何工作的，以及如何在应用程中创建和操纵进程。
                我们会展示应用程序员如何通过Linux系统调用来使用多个进程。
                学完本章之后，读者就能够编写带作业控制的Linux Shell了。
                同时，这里也会向读者初步展示程序的并发执行会引起不确定行为。
            }
            \item[第9章：虚拟内存]
            {
                我们讲述虚拟内存系统是希望读者对它是如何工作的以及它的特性有所了解。
                我们想让读者了解为什么不同的并发进程各自都有一个完全相同的地址范围，能共享某些页，而又独占另外一些页。
                我们还讲了一些管理和操纵虚拟内存的问题。
                特别地，我们讨论了存储分配操作，就像标准库的\emcode{malloc}和\emcode{free}操作。
                阐述这些内容是出于下面几个目的。
                他加强了这样一个概念，那就是虚拟内存空间只是一个字节数组，程序可以把它划分成不同的存储单元。
                它可以帮助读者理解当程序包含存储泄露和非法指针引用等内存引用错误时的后果。
                最后，许多应用程序员编写自己的优化了存储分配操作来满足应用程序的需要和特性。
                这一章比其他任何一章都更能展现将计算机系统中的硬件和软件结合起来阐述的优点。
                而传统的计算机体系结构和操作系统书籍都只讲述虚拟内存的某一方面。
            }
            \item[第10章：系统级I/O]
            {
                我们讲述Unix I/O的基本概念，例如文件和描述符。
                我们描述如何共享文件，I/O重定向是如何工作的，还有如何访问文件的元数据。
                我们还开发了一个健壮的带缓冲区的I/O包，可以正确处理一种称为short counts的奇特行为，也就是库函数只读取一部分的输入数据。
                我们阐述C的标准I/O库，以及它与Linux I/O的关系，重点谈到标准I/O的局限性，这些局限性使之不适合网络编程。
                总的来说，本章的主题是后面两章---网络和并发编程的基础。
            }
            \item[第11章：网络编程]
            {
                对编程而言，网络是非常有趣的I/O设备，它将许多我们前面文中学习的概念（比如进程、信号、字节顺序、内存映射和动态分配）联系在一起。
                网络程序还为下一章的主题---并发，提供了一个很令人信服的上下文。
                本章只是网络编程的一个很小的部分，使读者能够编写一个简单的Web服务器。
                我们还讲述位于所有网络程序底层的客户端-服务器模型。
                我们展现了一个程序员对Internet的观点，并且教读者如何用套接字接口来编写Internet客户端和服务器。
                最后，我们介绍超文本传输协议(HTTP)，并开发了一个简单的迭代式Web服务器。
            }
            \item[第12章：并发编程]
            {
                这一章以Internet服务器设计为例介绍了并发编程。
                我们比较对照了三种编写并发程序的基本机制（进程、I/O多路复用和线程），并且展示如何用它们来建造并发Internet服务器。
                我们探讨了用P、V信号量操作来实现同步、线程安全和可重入、竞争条件以及死锁等的基本原则。
                对大多数服务器应用来说，写并发代码都是很关键的。
                我们还讲述了线程级编程的使用方法，用这种方法来表达应用程序中的并行性，使得程序在多核处理器上能执行得更快。
                使用所有的核解决同一个计算问题需要很小心谨慎地协调并发线程，既要保证正确性，又要争取获得高性能。
            }
        \end{description}
    }

    \section{本版新增内容}
    {
        第二版以来最大的整体变化是，我们的介绍从以IA32和x86--64为基础，转变为完全以x86--64为基础。
        这种重心的转移影响了很多章节的内容。
        下面列出一些明显的变换：

        \begin{description}
            \item[第1章] 我们将第5章对Amdahl定理的讨论移到了本章。
            \item[第2章]
            {
                读者和评论家的反馈是一致的，本章的一些内容有点令人不知所措。
                因此，我们澄清了一些知识点，用更加数学的方式来描述，使得这些内容更容易理解。
                这使得读者能先略过数学细节，获得高层次的总体概念，然后回过头来进行更细致深入的阅读。
            }
            \item[第3章]
            {
                我们将之前基于IA32和x86--64的表现形式转换为完全基于x86--64，还更新了近期版本GCC产生的代码。
                同时，我们还介绍了对处理浮点数据的程序的机器级支持。
            }
            \item[第4章] 我们将之前基于32位架构的处理器设计修改为支持64位字和操作的设计。
            \item[第5章]
            {
                我们更新了内容以反映最近几代x86--64处理器的性能。
                通过引入更多的功能单元和更复杂的控制逻辑，我们开发的基于程序数据流表示的程序性能模型，其性能预测变得比之前更加可靠。
            }
            \item[第6章] 我们对内容进行了更新，以反映更多的近期技术。
            \item[第7章] 针对x86--64，我们重写了本章，扩充了关于用GOT和PLT创建位置无关代码的讨论，新增了一节描述更加强大的链接技术，比如\emreg{库打桩}。
            \item[第8章] 我们增加了对信号处理程序更细致的描述，包括异步信号安全的函数，编写信号处理程序的具体指导原则，以及用sigsuspend等待处理程序。
            \item[第9章] 本章变化不大。
            \item[第10章] 我们新增了一节说明文件和文件的层次结构。
            \item[第11章] 我们介绍了采用最新getaddrinfo和getnameinfo函数的、与协议无关和线程安全的网络编程。
            \item[第12章] 我们扩充了利用线程级并行性使得程序在多核机器上更快运行的内容。
        \end{description}
    }

    \section{本书的起源}
    {
        我们的学生中几乎没有人有机会亲自去构造一个计算机系统。
        另一方面，大多数学生，甚至包括所有的计算机科学家，也需要日常使用计算机和编写计算机程序。
        所以我们决定从程序员的角度来讲解系统，并采用这样的原则过滤要讲述的内容：
        我们只讨论那些影响用户级C语言程序的性能、正确性或实用性的主题。

        比如，我们排除了诸如硬件加法器和总线设计这样的主题。
        虽然我们谈及了机器语言，但是重点并不在于如何手工编写汇编语言，而是关注C语言编译器是如何将C语言的结构翻译成机器代码的，包括编译器是如何翻译指针、循环、过程调用以及开关(switch)语句的。
        更进一步地，我们将更广泛和全盘地看待系统，包括硬件和系统软件，涵盖了包括链接、加载、进程、信号、性能优化、虚拟内存、I/O以及网络与并发编程等在内的主题。
    }
}

\cleardoublepage

\endinput
